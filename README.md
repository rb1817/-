# 프레임워크와 라이브러리 차이

## - Framework(프레임워크)

------

프레임워크는 Application 개발시 코드의 품질, 필수적인 코드, 알고리즘, 암호화, 데이터베이스 연동 같은 기능들을 어느정도 구성이 되어있는 뼈대(구조)를 제공하도록 만들어진걸 프레임워크라고합니다. 

조금 어렵게 설명드렸는데, 개발 구조나 설계 시 제공되는 인터페이스의 집합입니다. 완성된 어플리케이션은 아니지만 어느정도 프로그래머가 제공된 프레임워크의 구조에서 어플리케이션을 개발해야합니다.

## - Library(라이브러리)

------

라이브러리는 특정 기능에 대한 API(도구 / 함수)를 모은 집합을 라이브러리라고 합니다.

그 기능을 사용하기위해 불러와서 호출하는 방식을 생각하시면 쉬울듯 합니다.

## - Framework와 Library의 차이

------

위의 내용으로만 봤을때는 단순히 라이브러리가 모이면 프레임워크처럼 보일 수 있습니다.

저도 그렇게 생각하고 있었고요 그리고 크게 틀린 생각도 아닌거 같습니다만

자료를 찾아보니 **토비의 스프링**에 아래와 같은 내용이 있습니다.

프레임워크는 단지 미리 만들어 둔 반제품이나, 확장해서 사용할 수 있도록 준비된 추상 라이브러리의 집합이 아니다.

프레임워크가 어떤 것인지 이해하려면 라이브러리와 프레임워크가 어떻게 다른지 알아야 한다.

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 

단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.

반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.

프레임워크에는 분명한 **제어의 역전** 개념이 적용되어 있어야 합니다.

애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 합니다.



# 클래스와 인스턴스의 차이

## -Class(클래스)

------

**객체의 설계도(blueprint)**를 코드로 나타낸 것을 의미합니다.

다시 말해, **객체를 프로그램적으로 만들기 위한 설계 코드**란 의미입니다.

## -Instance(인스턴스)

------

객체(Object)는 현실의 대상(Object)과 비슷하여, 상태나 행동 등을 가지지만, 소프트웨어 관점에서는 

그저 콘셉에 불과하다. 소프트웨어에서 객체를 구현하기 위해서는 콘셉 이상으로 많은 것들을 사고하

여 구현해야 하므로, 이를 위한 설계도로 클래스를 작성한다. **설계도를 바탕으로 객체를 소프트웨어에** 

**실체화 하면**  그것이 인스턴스(Instance)가 되고, 이 과정을 인스턴스화(instantiation)라고 한다.  



# RESTful API란?

## -API란

------

응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻힌다.



## **-REST하다는 것은 무엇일까?**

------

### REST(REpresentational State Transfer)란

REST 는 네트워크 애플리케이션을 설계하는 아키텍처 스타일이다. 기계와 연결하는 등의 CORBBA, PRC 또는 SOAP같은 복잡한 메커니즘을 사용하는 것보다, 간단한 HTTP 기반 (web service)으로 기계 사이의 통화를 하는데 사용된다.

따라서 Restful API는 REST 특징을 지키면서 API를 제공하는 것을 의미한다. (일종의 Coding Convention이랄까. 설계원칙, 가이드를 지키면서 개발을 하자는 의미인듯 싶다.)

POST, GET, PUT, DELETE 이 4가지의 Method를 가지고 CRUD를 할 수 있습니다.

| METHOD | 역할                                                         |
| ------ | ------------------------------------------------------------ |
| POST   | POST를 통해 해당 URI를 요청하면 리소스를 생성합니다.         |
| GET    | GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. |
| PUT    | PUT를 통해 해당 리소스를 수정합니다.                         |
| DELETE | DELETE를 통해 리소스를 삭제합니다.                           |

다음과 같은 식으로 URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙입니다.



# ORM이란 무엇인가?

OOP 언어와 데이터를 다루는 RDBMS 와의 상이한 시스템을 매핑하여, 쉽게 데이터 관련 [OOP](http://en.wikipedia.org/wiki/Object-oriented_programming) 프로그래밍을 쉽게 하도록 하기 위한 기술이다.

**ORM은** **Object-Relational-Mapping의 약어**입니다.전통적으로 프로그램이 DB를 조작하기 위해서는 명령어(DB query string)를 생성하여 DB에 명령을 주고 결과를 받았습니다. 이와 다른 개념으로 DB를 프로그램의 객체(object)에 연결(map)하여 주는 것이 ORM입니다.ORM은 DB data와 프로그램의 object를 연결하며 DB와 프로그래머 사이의 중간 역할을 해줍니다. 프로그래머는 DB에 직접 명령을 내리지 않고 연결된 객체의 함수를 사용해서 DB에 명령을 내리게 됩니다.

```
장점
객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중하 수 있게 도와준다.
- 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
- 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
- SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 가독 / 생산성이 증가한다.
재사용 및 유지보수의 편리성이 증가한다.
- ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용하여 사용할 수 있다.
- 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
- 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
DBMS에 대한 종속성이 줄어든다.
- 대부분 ORM 솔루션은 DB에 종속적이지 않다.
- 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
- 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
- 또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.


단점
완벽한 ORM 으로만 서비스를 구현하기가 어렵다.
- 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
- 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
- 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
- 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
- DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 한 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
- 이미 프로시저가 많은 시스템에선 다시 오브젝트로 바꿔야하며, 여기서 생산성저하나 리스크가 많이 발생할 수 있다.
```



## -RDBMS란

---

관계형 데이터베이스란 용어는 최소한 다음 두 요건을 만족하는 데이터베이스 시스템이라는 더 광범위한 의미로 사용되었다. 

- 사용자에게 데이터를 [관계](https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4))로서 표현한다. 즉, 행과 열의 집합으로 구성된 [테이블](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%9D%B4%EB%B8%94_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4))의 *묶음* 형식으로 데이터를 제공한다.
- 테이블 형식의 데이터를 조작할 수 있는 관계 연산자를 제공한다.



# PUT과 PATCH의 차이점

PUT : 자원의 전체 교체, 자원내 모든 필드영역 필요

​         (만약 일부만 전달할 경우, 그외의 필드 모두 null or 초기값 처리)

PATCH : 자원의 부분 교체, 자원내 일부 필드영역 필요

용도에 맞게 쓰자.  PUT을 쓰려고 했는데 유지보수 관점에서 미숙한 개발자의 실수를 방지하고자 PATCH만 쓰기로 결정하기도 한다.



# MVC 패턴

MVC란 **M**odel **V**iew **C**ontroller의 약자로 에플리케이션을 세가지의 역할로 구분한 개발 방법론이다. 아래의 그림처럼 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 된다.  

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Router-MVC-DB.svg/512px-Router-MVC-DB.svg.png) 

### -Controller

값검증

사용자가 접근 한 URL에 따라서 사용자의 요청사항을 파악한 후에 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다. 

모델에 명령을 보냄으로써 모델의 상태를 변경할 수 있다. (예: 워드 프로세서에서 문서를 편집하는 것) 또, 컨트롤러가 관련된 뷰에 명령을 보냄으로써 모델의 표시 방법을 바꿀 수 있다. (문서를 스크롤하는 것) 

### -Model



일반적으로 CI의 모델은 데이터베이스 테이블에 대응된다. 이를테면 Topic이라는 테이블은 topic_model이라는 Model을 만든다. 그런데 이 관계가 강제적이지 않기 때문에 규칙을 일관성 있게 정의하는 것이 필요하다.

모델의 상태에 변화가 있을 때 컨트롤러와 뷰에 이를 통보한다. 이와 같은 통보를 통해서 뷰는 최신의 결과를 보여줄 수 있고, 컨트롤러는 모델의 변화에 따른 적용 가능한 명령을 추가·제거·수정할 수 있다. 어떤 MVC 구현에서는 통보 대신 뷰나 컨트롤러가 직접 모델의 상태를 [읽어 오기](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))도 한다. 

### -View

View는 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너이다. 

사용자가 볼 결과물을 생성하기 위해 모델로부터 정보를 얻어 온다. 



## 디자인 패턴

디자인 패턴은 건축으로치면 공법에 해당하는 것으로 소프트웨어의 개발 방법을 공식화 한 것이다. 소수의 뛰어난 엔지니어가 해결한 문제를 다수의 엔지니어들이 처리 할 수 있도록 한 규칙이면서, 구현자들 간의 커뮤니케이션의 효율성을 높이는 기법이다. 



# 브라우저 주소창에 URL이 입력되고 화면이 보이기 까지의 과정을 아는대로 서술하시오

## -브라우저의 구조

---

![brouser1](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png) 

1. 사용자 인터페이스 - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. 렌더링 엔진 - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
   * HTML데이터를 파싱한다.
   * 파싱한 결과로 DOM Tree를 만든다.
   * 파싱 중 CSS파일 링크를 만나면 CSS파일을 요청해서 받고, CSS 파일을 읽어 CSSOM(CSS Object Model)을 만든다.
   * DOM Tree와 CSSOM을 사용해 Render Tree를 만든다.
   * Render Tree의 노드들이 화면의 어디에 위치할지 계산한다.
   * 웹페이지를 그린다.
4. 통신 - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. 자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행.
7. 자료 저장소 - 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '[웹](http://www.html5rocks.com/en/features/storage)[ ](http://www.html5rocks.com/en/features/storage)[데이터](http://www.html5rocks.com/en/features/storage)[ ](http://www.html5rocks.com/en/features/storage)[베이스](http://www.html5rocks.com/en/features/storage)'가 정의되어 있다.

